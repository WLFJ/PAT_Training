<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 9.4.7 (461683)"/><meta name="altitude" content="831"/><meta name="author" content="Yves Wong"/><meta name="created" content="2020-11-23 08:02:39 +0000"/><meta name="latitude" content="38.0126953125"/><meta name="longitude" content="112.450484218724"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2020-11-24 07:37:38 +0000"/><title>图论初步</title></head><body><div>一、存图的方式</div><div>除了我们都知道的邻接矩阵，还有邻接表。这个我们需要着重记忆，因为这个实在太好用了。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">/*</span></div><div><font face="Monaco">记忆：</font></div><div><font face="Monaco">因为我们本身插入的时候就是用反着来的，所以是“尾、边、头”反转。</font></div><div><font face="Monaco">如果我们把ver数组理解为头指针数组，则可以记忆为“头、边、下面的尾巴”</font></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">*/</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">void add(int x, int y, int z){</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    ver[++tot] = y, edge[tot] = z, next[tot] = head[x], head[x] = tot;</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">}</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">/*</span></div><div><font face="Monaco">这里面只有head是真实通过节点得到的，其他都是通过tot数组维护的</font></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">*/</span></div></div><div>下面我们看看遍历的办法</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>//从x出发的所有边</div><div>for(int i = head[x]; i; i = next[i]){</div><div>    int y = var[i], z = edge[i];</div><div>}</div><div>//我们看到只要不为0就可以一直循环下去</div></div><div><br/></div><div>二、相关算法看一看</div><div><br/></div><ol><li><div>dijkstra</div></li></ol><div>简单版本的代码会了之后，复杂的就会了。注意其不能计算带负数的边。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>void dijkstra(int startp){</div><div>    memset(dis, 0x3f, siezof(dis));</div><div>    dis[startp] = 0;</div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    memset(v, 0, sizeof(v));</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    for(int i = 1; i &lt; n; i ++){ // 循环n - 1次，再多循环一次如果dis数组发生变化说明其中有负环了</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">        int x = 0;</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">        for(int j = 1; j &lt;= n; j ++){</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">            if(!v[j] &amp;&amp; （x == 0 || dis[j] &gt; dis[x])){ // 注意初始条件</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">                x = j;</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">            }</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">        }</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">        v[x] = 1;</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">        for(int y = 1; y &lt;= n; y ++){</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">            dis[y] = max(dis[y], dis[y] + a[y][i]);</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">        }</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    }</span></div><div>}</div></div><div><br/></div><div>之后我们看看带堆优化的，这样写起来更方便：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">const int N = 100010, M = 100010;</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">int head[N], ver[N], edge[M], Next[M], d[N];</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">bool v[N];</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">int n, m, tot;</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">&lt;pair&lt;int, int&gt; &gt; q;</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">void add(int x, int y, int z){</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    ver[++tot] = y, edge[tot] = z, Next[tot] = head[x], head[x] = tot;</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">}</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">void dijkstra(int startp){</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    memset(d, 0x3f, sizeof(d));</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    memset(v, 0, sizeof(v));</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    d[</span>startp] = 0;</div><div><span>    q.push(make_pair(0, startp));</span><br/></div><div>    while(q.size()){</div><div>        int x = q.top().second; q.pop();</div><div>        if(v[x]) continue;</div><div>        v[x] = 1;</div><div>        for(int i = head[x]; i; i = Next[i]){</div><div>            int y = ver[i], z = edge[i];</div><div>            if(d[y] &gt; d[x] + z){ // 更新一下，让里面都是最小的</div><div>                d[y] = d[x] + z;</div><div>                q.push(make_pair(-d[y], y));</div><div>            }</div><div>        }</div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    }</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">}</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">int main(void){</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    cin &gt;&gt; n &gt;&gt; m;</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    for(int i = 1; i &lt;= m; i ++){</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">        int x, y, z;</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">        add(x, y, z);</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    }</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    dijkstra(startp);</span></div><div><font face="Monaco">    for(int i = 1; i &lt;= n; i ++){</font></div><div><font face="Monaco">        cout &lt;&lt; d[i] &lt;&lt; endl;</font></div><div><font face="Monaco">    }</font></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    return 0;</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">}</span></div></div><div><br/></div><ol start="2"><li><div>Bellman-Ford 算法和SPFA算法</div></li></ol><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>const int N = 100010, M = 100010;</div><div>int head[N], ver[N], edge[M], Next[M], d[N];</div><div>int n, m, tot;</div><div><br/></div><div>queue&lt;int&gt; q;</div><div>bool v[N];</div><div><br/></div><div>void add(int x, int y, int z){</div><div>    ver[++ tot] = y, edge[tot] = z, Next[tot] = head[x], head[x] = tot;</div><div>}</div><div><br/></div><div>void spfa(int startp){</div><div>    memset(d, 0x3f, sizeof(d));</div><div>    memset(v, 0, sizeof(v));</div><div>    d[startp] = 0;v[startp] = 1;</div><div>    q.push(startp);</div><div>    while(q.size()){</div><div>        int x = q.front(); q.pop();</div><div>        v[x] = 0;</div><div>        for(int i = head[x]; i; i = Next[i]){</div><div>            int y = ver[i], z = edge[i];</div><div>            if(d[y] &gt; d[x] + z){</div><div>                d[y] = d[x] + z;</div><div>                if(!v[y]) q.push(y), v[y] = 1;</div><div>            }</div><div>        }</div><div>    }</div><div>}</div><div><br/></div><div>int main(void){</div><div>    cin &gt;&gt; n &gt;&gt; m;</div><div>    for(int i = 1; i &lt;= m; i ++){</div><div>        int x, y, z;</div><div>        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</div><div>        add(x, y, z);</div><div>    }</div><div>    spfa();</div><div>    for(int i = 1; i &lt;= n; i ++){</div><div>        cout &lt;&lt; d[i] &lt;&lt; “ “;</div><div>    }</div><div>    cout &lt;&lt; endl;</div><div>    return 0;</div><div>}</div></div><div><br/></div><div>三、任意两点的最短路</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>// 除了可以求解最短路，还可以求解关系传递</div><div>int d[310][310], n, m;</div><div>int main(void){</div><div>    cin &gt;&gt; n &gt;&gt; m;</div><div>    memset(d, 0x3f, sizeof(d));</div><div>    for(int i = 1; i &lt;= n; i ++) d[i][i] = 0;</div><div>    for(int i = 1; i &lt;= m; j ++){</div><div>        int x, y, z;</div><div>        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</div><div>        d[x][y] = min(d[x][y], z); // 图论注意多条边的问题</div><div>    }</div><div>    // 先遍历中间的，其次是两边的。</div><div>    for(int k = 1; k &lt;= n; k ++){</div><div>        for(int i = 1; i &lt;= n; i ++){</div><div>            for(int j = 1; j &lt;= n; j ++){</div><div>                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);</div><div>            }</div><div>        }</div><div>    }    </div><div>    for(int i = 1; i &lt;= n; i ++){</div><div>        for(int j = 1; j &lt;= n; j ++){</div><div>            cout &lt;&lt; d[i][j] &lt;&lt; “ “;</div><div>        }</div><div>        cout &lt;&lt; endl;</div><div>    }</div><div>    return 0;</div><div>}</div></div><div><br/></div><div>四、最小生成树</div><div>我们看到这是个很简单的算法，将边排序，使用并差集</div><ol><li><div>Kruskal</div></li></ol><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>struct res { int x, y, z; } edge[500010];</div><div>int fa[100010], n, m, ans;</div><div>bool operator &lt; (rec a, rec b){</div><div>    return a.z &lt; b.z;</div><div>}</div><div><div><br/></div><div>int get(int x){</div></div><div><span>    if(x == fa[x]) return x;</span><br/></div><div><span><span>    return fa[x] = get(fa[x]);</span><br/></span></div><div>}</div><div><br/></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">int main(void){</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    cin &gt;&gt; n &gt;&gt; m;</span><br/></span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span><span>    for(int i = 1; i &lt;= m; i ++){</span><br/></span></span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span><span><span>    <span>    cin &gt;&gt; edge[i].x &gt;&gt; </span></span></span></span></span>edge[i].y &gt;&gt; edge[i].z;</div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span><span><span>    </span>}</span></span></span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span><span><span>    sort(edge + 1, edge + m + 1);</span><br/></span></span></span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span><span><span><span>    for(int i = 1; i &lt;= n; i ++){</span><br/></span></span></span></span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span><span><span><span><span>    <span>    fa[i] = i;</span></span><br/></span></span></span></span></span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span><span><span><span><span>    }</span></span></span></span></span></span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span><span><span><span><span><span>    int ans = 0;</span><br/></span></span></span></span></span></span></div><div><font face="Monaco">    for(int i = 1; i &lt;= m; i ++){</font><br/></div><div><font face="Monaco"><span>    <span>    int x = get(edge[i].x);</span></span><br/></font></div><div><font face="Monaco"><span><span><span>    <span>    int y = get(edge[i].y);</span></span><br/></span></span></font></div><div><font face="Monaco"><span><span><span><span><span>    <span>    if(x == y){</span></span><br/></span></span></span></span></font></div><div><font face="Monaco"><span><span><span><span><span><span><span>    <span>    <span>    continue;</span></span></span><br/></span></span></span></span></span></span></font></div><div><font face="Monaco"><span><span><span><span><span><span><span>    <span>    </span></span>}</span></span></span></span></span></span></font></div><div><font face="Monaco"><span><span><span><span><span><span><span>    <span>    fa[x] = y;</span></span><br/></span></span></span></span></span></span></font></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    <span>    ans += edge[i].z;</span></span><br/></span></div><div><font face="Monaco"><span>    </span>}</font></div><div><font face="Monaco"><span>    cout &lt;&lt; ans &lt;&lt; endl;</span><br/></font></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    return 0;</span><br/></span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">}</span></div></div><div><br/></div><ol start="2"><li><div>Prim</div></li></ol><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">int a[3010],b[3010], n, m, ans;</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">bool v[3010];</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">void prim(){</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    // 插棒棒算法，每次选择一个最小的棒棒，之后将其棒棒的出点全部标记一圈。</span><br/></span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    memset(d, 0x3f, sizeof(d));</span><br/></span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span><span>    memset(v, 0, sizeof(v));</span><br/></span></span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span><span><span>    d[1] = 0;</span><br/></span></span></span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span><span><span><span>    for(int y = 1; y &lt;= n; y ++){</span><br/></span></span></span></span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span><span><span><span><span>    <span>    int x = 0;</span></span><br/></span></span></span></span></span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span><span><span><span><span><span><span>    <span>    for(int j = 1; j &lt;= n; j ++){</span></span><br/></span></span></span></span></span></span></span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span><span><span><span><span><span><span><span><span>    <span>    <span>    if(!v[j] &amp;&amp; ( x == 0 || d[j] &lt; d[x])) x = j;</span></span></span><br/></span></span></span></span></span></span></span></span></span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span><span><span><span><span><span><span><span><span>    <span>    </span></span>}</span></span></span></span></span></span></span></span></span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    <span>    v[x] ++;</span></span><br/></span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span><span><span>    <span>    for(int y = 1; y &lt;= n; y ++){</span></span><br/></span></span></span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span><span><span><span><span>    <span>    <span>    if(!v[y]) d[y] = min(d[y], a[x][y]);</span></span></span><br/></span></span></span></span></span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span><span><span><span><span>   <span>    </span> </span>}</span></span></span></span></span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span><span><span><span><span><span>   </span>  </span>}</span></span></span></span></span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">}</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">int main(void){</span></div><div><span style="color: rgb(51, 51, 51); font-family: Monaco; font-size: 12px;">    cin &gt;&gt; n &gt;&gt; m;</span><br/></div><div><span style="color: rgb(51, 51, 51); font-family: Monaco; font-size: 12px;"><span>    memset(a, 0x3f, sizeof(a));</span><br/></span></div><div><span style="color: rgb(51, 51, 51); font-family: Monaco; font-size: 12px;"><span><span>    for(int i = 1; i &lt;= n; i ++) a[i][i] = 0;</span><br/></span></span></div><div><span style="color: rgb(51, 51, 51); font-family: Monaco; font-size: 12px;"><span><span><span>    for(int i = 1; i &lt;= m; i ++){</span><br/></span></span></span></div><div><span style="color: rgb(51, 51, 51); font-family: Monaco; font-size: 12px;"><span><span><span><span>    <span>    int x, y, z;</span></span><br/></span></span></span></span></div><div><span style="color: rgb(51, 51, 51); font-family: Monaco; font-size: 12px;"><span><span><span><span><span><span>    <span>    cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span></span><br/></span></span></span></span></span></span></div><div><span style="color: rgb(51, 51, 51); font-family: Monaco; font-size: 12px;"><span><span><span><span><span><span><span><span>    <span>    a[y][x] = a[x][y] = min(a[x][y], z);</span></span><br/></span></span></span></span></span></span></span></span></div><div><span style="color: rgb(51, 51, 51); font-family: Monaco; font-size: 12px;"><span><span><span><span>    </span>}</span></span></span></span></div><div><span style="color: rgb(51, 51, 51); font-family: Monaco; font-size: 12px;"><span><span><span><span>    prim();</span><br/></span></span></span></span></div><div><span style="color: rgb(51, 51, 51); font-family: Monaco; font-size: 12px;"><span><span><span><span><span>    for(int i 2; i &lt;= n; i ++) ans += d[i];</span><br/></span></span></span></span></span></div><div><font face="Monaco">    cout &lt;&lt; ans &lt;&lt; endl;</font><br/></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    return 0;</span><br/></span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">}</span></div></div><div><br/></div></body></html>